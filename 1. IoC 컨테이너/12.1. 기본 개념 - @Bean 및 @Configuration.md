# 기본 개념: @Bean 및 @Configuration

스프링의 자바 설정 지원의 핵심 아티팩트는 `@Configuration` 어노테이션이 달린 클래스와 `@Bean` 어노테이션이 달린 메서드이다.

`@Bean` 어노테이션은 메서드가 스프링 IoC 컨테이너에서 관리할 새 객체를 인스턴스화, 설정 및 초기화한다는 것을 나타내는 데 사용된다. 스프링의 `<beans/>` XML 설정에 익숙한 사람들을 위해 `@Bean` 어노테이션은 `<bean/>` 요소와 동일한 역할을 한다. 모든 스프링 `@Component`에 `@Bean` 어노테이션 메서드를 사용할 수 있다. 그러나 `@Configuration` 빈과 함께 가장 자주 사용된다.

클래스에 `@Configuration` 어노테이션을 달면 해당 클래스의 주요 목적이 빈 정의의 소스임을 나타낸다. 또한 `@Configuration` 클래스를 사용하면 동일한 클래스에서 다른 `@Bean` 메서드를 호출하여 빈 간 의존성을 정의할 수 있다. 가장 간단한 `@Configuration` 클래스는 다음과 같다.

```java
@Configuration
public class AppConfig {

    @Bean
    public MyServiceImpl myService() {
	return new MyServiceImpl();
    }
}
```

앞의 `AppConfig` 클래스는 다음 스프링 `<beans/>` XML과 동일하다.

```xml
<beans>
    <bean id="myService" class="com.acme.services.MyServiceImpl"/>
</beans>
```

> ### @Bean 메서드 간의 로컬 호출이 있는 경우와 없는 경우의 @Configuration 클래스
> 
> 일반적인 시나리오에서 `@Bean` 메서드는 `@Configuration` 클래스 내에서 선언되어 전체 설정 클래스 처리가 적용되고 따라서 교차 메서드 참조가 컨테이너의 라이프사이클 관리로 리디렉션되도록 해야 한다. 이렇게 하면 동일한 `@Bean` 메서드가 일반 자바 메서드 호출을 통해 실수로 호출되는 것을 방지할 수 있으므로 추적하기 어려운 미묘한 버그를 줄이는 데 도움이 된다.
> 
> `@Configuration`으로 어노테이션되지 않은 클래스 내에서 `@Bean` 메서드가 선언되거나 `@Configuration(proxyBeanMethods=false)`이 선언되면 "라이트" 모드에서 처리되는 것으로 참조된다. 이러한 시나리오에서 `@Bean` 메서드는 특별한 런타임 처리 없이(즉, CGLIB 서브클래스를 생성하지 않고) 사실상 범용 팩토리 메서드 메커니즘이다. 이러한 메서드에 대한 사용자 정의 자바 호출은 컨테이너에 의해 가로채지지 않으므로 일반 메서드 호출처럼 동작하며, 주어진 빈에 대한 기존 싱글톤(또는 스코프가 지정된) 인스턴스를 재사용하는 대신 매번 새 인스턴스를 생성한다.
> 
> 결과적으로 런타임 프록시가 없는 클래스의 `@Bean` 메서드는 빈 간 의존성을 전혀 선언할 수 없다. 대신, 해당 메서드는 포함된 컴포넌트의 필드와, 선택적으로, 팩토리 메서드가 자동 연결된 공동 협력자를 받기 위해 선언할 수 있는 인수에 대해 작동할 것으로 예상된다. 따라서 이러한 `@Bean` 메서드는 다른 `@Bean` 메서드를 호출할 필요가 없으며, 모든 호출은 팩토리 메서드 인수를 통해 대신 표현할 수 있다. 이로 인한 긍정적인 측면은 런타임에 CGLIB 서브클래싱을 적용할 필요가 없어 오버헤드와 메모리 사용량이 줄어든다는 것이다.

다음 섹션에서는 `@Bean` 및 `@Configuration` 어노테이션에 대해 자세히 설명한다. 그러나 먼저 자바 기반 설정을 사용하여 스프링 컨테이너를 생성하는 다양한 방법에 대해 설명한다.
