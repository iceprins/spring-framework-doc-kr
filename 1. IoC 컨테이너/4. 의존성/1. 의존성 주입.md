# 의존성 주입

의존성 주입(DI)은 객체가 다른 객체(즉, 함께 작동하는 다른 객체)와의 의존성을 생성자 인수, 팩토리 메서드의 인수, 또는 객체 인스턴스가 생성되거나 팩토리 메서드에서 반환된 후에 설정된 속성을 통해서만 정의하는 프로세스이다. 그런 다음 컨테이너는 빈을 생성할 때 이러한 의존성을 주입한다. 이 프로세스는 기본적으로 빈이 직접 클래스의 직접적인 생성 또는 서비스 로케이터 패턴을 사용하여 의존성의 인스턴스화 또는 위치를 제어하는 것과는 정반대(이런 이유로 제어의 역전이라고 말한다)이다.

DI 원칙을 사용하면 코드가 더 깔끔해지며, 객체에 의존성이 제공될 때 분리가 더 효과적이다. 객체는 의존성을 조회하지 않으며 의존성의 위치나 클래스를 알지 못한다. 결과적으로 클래스는 특히 인터페이스나 추상 기본 클래스에 의존하는 경우 유닛 테스트에서 stub 또는 mock 구현을 사용할 수 있도록 하여 테스트하기가 더 쉬워진다.

DI는 크게 "생성자 기반 의존성 주입"과 "setter 기반 의존성 주입" 두 가지 종류가 있다.

## 생성자 기반 의존성 주입

생성자 기반 DI는 컨테이너가 각각 의존성을 나타내는 여러 인수를 사용하여 생성자를 호출함으로써 수행된다. 특정 인수로 `정적` 팩토리 메서드를 호출하여 빈을 생성하는 것은 거의 동일하며, 이 설명에서는 생성자와 `정적` 팩토리 메서드에 대한 인수를 비슷하게 취급한다. 다음 예시는 생성자 주입으로만 의존성을 주입할 수 있는 클래스를 보여준다.

```java
public class SimpleMovieLister {

    // SimpleMovieLister는 MovieFinder에 대한 의존성이 있다
    private final MovieFinder movieFinder;
	
    // 스프링 컨테이너가 MovieFinder를 주입할 수 있는 생성자
    public SimpleMovieLister(MovieFinder movieFinder) {
	this.movieFinder = movieFinder;
    }
	
    // 실제로 주입된 MovieFinder를 사용하는 비즈니스 로직은 생략...
}
```

이 클래스에는 특별한 것이 없다. 컨테이너 특정 인터페이스, 기본 클래스 또는 어노테이션에 대한 의존성이 없는 POJO이다.

### 생성자 인수 해결

생성자 인수 해결 매칭은 인자의 타입을 사용하여 발생한다. 빈 정의의 생성자 인수에 잠재적인 모호성이 존재하지 않는 경우, 빈 정의에서 생성자 인수가 정의되는 순서는 빈이 인스턴스화될 때 해당 인수가 적절한 생성자에게 제공되는 순서이다. 다음 클래스를 생각해 보자.

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
	// ...
    }
}
```

`ThingTwo`와 `ThingThree` 클래스가 상속으로 관련이 없다고 가정하면 잠재적인 모호성은 존재하지 않는다. 따라서 다음 설정은 정상적으로 작동하며 `<constructor-arg/>` 요소에 생성자 인수 인덱스나 유형을 명시적으로 지정할 필요가 없다.

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
	<constructor-arg ref="beanTwo"/>
	<constructor-arg ref="beanThree"/>
    </bean>
	
    <bean id="beanTwo" class="x.y.ThingTwo"/>
	
    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

다른 빈이 참조되면 타입을 알 수 있으므로 (앞의 예시에서와 같이) 일치시킬 수 있다. `<value>true</value>`와 같은 단순 타입이 사용되는 경우 스프링은 값의 타입을 결정할 수 없으므로 도움 없이는 타입별로 매칭할 수 없다. 다음 클래스를 생각해 보자.

```java
package examples;

public class ExampleBean {

    // 최종 정답을 계산하는 데 걸리는 연도 수
    private final int years;
	
    // 삶, 우주, 그리고 모든 것에 대한 해답
    private final String ultimateAnswer;
	
    public ExampleBean(int years, String ultimateAnswer) {
	this.years = years;
	this.ultimateAnswer = ultimateAnswer;
    }
}
```

앞의 시나리오에서, 다음 예시와 같이 `type` 속성을 사용하여 생성자 인수의 타입을 명시적으로 지정하면 컨테이너는 단순 타입과의 타입 매칭을 사용할 수 있다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

다음 예시에서와 같이 `index` 속성을 사용하여 생성자 인수의 인덱스를 명시적으로 지정할 수 있다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

인덱스를 지정하면 여러 개의 단순한 값의 모호성을 해결할 수 있을 뿐만 아니라 생성자에 동일한 타입의 인수가 두 개 있는 경우 모호성을 해결할 수 있다.
