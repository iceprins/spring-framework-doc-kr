# @Bean 어노테이션 사용하기

`@Bean`은 메서드 수준 어노테이션이며 XML `<bean/>` 요소와 직접적으로 대응된다. 이 어노테이션은 다음과 같이 `<bean/>`에서 제공하는 일부 속성을 지원한다.

- [init-method](https://github.com/iceprins/spring-framework-doc-kr/blob/main/1.%20IoC%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/6.%20%EB%B9%88%EC%9D%98%20%EC%84%B1%EC%A7%88%20%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95.md#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BD%9C%EB%B0%B1)
- [destroy-method](https://github.com/iceprins/spring-framework-doc-kr/blob/main/1.%20IoC%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/6.%20%EB%B9%88%EC%9D%98%20%EC%84%B1%EC%A7%88%20%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95.md#%EC%86%8C%EB%A9%B8-%EC%BD%9C%EB%B0%B1)
- [autowiring](https://github.com/iceprins/spring-framework-doc-kr/blob/main/1.%20IoC%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/4.%20%EC%9D%98%EC%A1%B4%EC%84%B1/5.%20%ED%98%91%EB%A0%A5%EC%9E%90%20%EC%9E%90%EB%8F%99%20%EC%97%B0%EA%B2%B0.md)
- `name`

`@Configuration` 어노테이션 또는 `@Component` 어노테이션이 있는 클래스에서 `@Bean` 어노테이션을 사용할 수 있다.

## 빈 선언

빈을 선언하려면 메서드에 `@Bean` 어노테이션을 달 수 있다. 이 메서드를 사용하여 메서드의 반환 값으로 지정된 타입의 `ApplicationContext` 내에 빈 정의를 등록할 수 있다. 기본적으로 빈 이름은 메서드 이름과 동일하다. 다음 예시는 `@Bean` 메서드 선언을 보여준다.

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
	return new TransferServiceImpl();
    }
}
```

앞의 설정은 다음 스프링 XML과 정확히 동일하다.

```xml
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

두 선언 모두 다음 텍스트 이미지에서 볼 수 있듯이 `TransferServiceImpl` 타입의 객체 인스턴스에 바인딩된 `ApplicationContext`에서 `transferService`라는 이름의 빈을 사용할 수 있게 한다.

```
transferService -> com.acme.TransferServiceImpl
```

디폴트 메서드를 사용하여 빈을 정의할 수도 있다. 이렇게 하면 디폴트 메서드에 대한 빈 정의로 인터페이스를 구현하여 빈 설정을 구성할 수 있다.

```java
public interface BaseConfig {

    @Bean
    default TransferServiceImpl transferService() {
	return new TransferServiceImpl();
    }
}

@Configuration
public class AppConfig implements BaseConfig {

}
```

다음 예시와 같이 인터페이스(또는 베이스 클래스) 반환 타입을 사용하여 `@Bean` 메서드를 선언할 수도 있다.

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
	return new TransferServiceImpl();
    }
}
```

그러나 이는 고급 타입 예측의 가시성을 지정된 인터페이스 타입(`TransferService`)으로 제한한다. 그런 다음, 영향을 받는 싱글톤 빈이 인스턴스화된 후에야 컨테이너에서 전체 타입(`TransferServiceImpl`)이 알려진다. 지연되지 않는 싱글톤 빈은 선언된 순서에 따라 인스턴스화되므로, 다른 컴포넌트가 선언되지 않은 타입으로 매칭하려고 할 때(예: `@Autowired TransferServiceImpl`, 이는 `transferService` 빈이 인스턴스화된 후에만 해결됨) 서로 다른 타입 매칭 결과를 볼 수 있다.

> ### 팁
> 
> 타입을 선언된 서비스 인터페이스로 일관되게 참조하면 `@Bean` 반환 타입도 안전하게 그 설계 결정에 따를 수 있다. 그러나 여러 인터페이스를 구현하는 컴포넌트나 구현 타입으로 참조될 가능성이 있는 컴포넌트의 경우, 가능한 한 가장 구체적인 반환 타입을 선언하는 것이 더 안전하다(최소한 빈을 참조하는 주입 지점에서 요구하는 만큼 구체적으로).
